## 简介

类（class）是面向对象编程的基本构件，封装了属性和方法，TypeScript 给予了全面支持。

### 属性的类型

类的属性可以在顶层声明，也可以在构造方法内部声明。

对于顶层声明的属性，可以在声明时同时给出类型。

```typescript
class Point {
  x:number;
  y:number;
}
```

上面声明中，属性 `x`和 `y`的类型都是 `number`。

如果不给出类型，TypeScript 会认为 `x`和 `y`的类型都是 `any`。

如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。

```typescript
class Point {
  x = 0;
  y = 0;
}
```

上面示例中，属性 `x`和 `y`的类型都会被推断为 number。

TypeScript 有一个配置项 `strictPropertyInitialization`，只要打开（默认是打开的），就会检查属性是否设置了初值，如果没有就报错。

```typescript
// 打开 strictPropertyInitialization
class Point {
  x: number; // 报错
  y: number; // 报错
}
```

上面示例中，如果类的顶层属性不赋值，就会报错。如果不希望出现报错，可以使用非空断言。

```typescript
class Point {
  x!: number;
  y!: number;
}
```

上面示例中，属性 `x`和 `y`没有初值，但是属性名后面添加了感叹号，表示这两个属性肯定不会为空，所以 TypeScript 就不报错了，详见《类型断言》一章。

### readonly 修饰符

属性名前面加上 readonly 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。

```typescript
class A {
  readonly id = 'foo';
}

const a = new A();
a.id = 'bar'; // 报错
```

上面示例中，`id`属性前面有 readonly 修饰符，实例对象修改这个属性就会报错。

readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。

```typescript
class A {
  readonly id:string;

  constructor() {
    this.id = 'bar'; // 正确
  }
}
```

上面示例中，构造方法内部设置只读属性的初值，这是可以的。

```typescript
class A {
  readonly id:string = 'foo';

  constructor() {
    this.id = 'bar'; // 正确
  }
}
```

上面示例中，构造方法修改只读属性的值也是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。

### 方法的类型

类的方法就是普通函数，类型声明方式与函数一致。

```typescript
class Point {
  x:number;
  y:number;

  constructor(x:number, y:number) {
    this.x = x;
    this.y = y;
  }

  add(point:Point) {
    return new Point(
      this.x + point.x,
      this.y + point.y
    );
  }
}
```

上面示例中，构造方法 `constructor()`和普通方法 `add()`都注明了参数类型，但是省略了返回值类型，因为 TypeScript 可以自己推断出来。

类的方法跟普通函数一样，可以使用参数默认值，以及函数重载。

下面是参数默认值的例子。

```typescript
class Point {
  x: number;
  y: number;

  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
}
```

上面示例中，如果新建实例时，不提供属性 `x`和 `y`的值，它们都等于默认值 `0`。

下面是函数重载的例子。

```typescript
class Point {
  constructor(x:number, y:string);
  constructor(s:string);
  constructor(xs:number|string, y?:string) {
    // ...
  }
}
```

上面示例中，构造方法可以接受一个参数，也可以接受两个参数，采用函数重载进行类型声明。

另外，构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。

```typescript
class B {
  constructor():object { // 报错
    // ...
  }
}
```

上面示例中，构造方法声明了返回值类型 `object`，导致报错。
